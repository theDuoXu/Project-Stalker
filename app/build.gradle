plugins {
    id 'java'
    id 'application'
    id 'org.openjfx.javafxplugin' version '0.1.0'
    id 'me.champeau.jmh' version '0.7.2'
}

group = 'projectstalker'
version = '0.4 - ALPHA'

repositories {
    mavenCentral()
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

javafx {
    version = "25"
    modules = ['javafx.controls', 'javafx.fxml', 'javafx.graphics', 'javafx.swing']
}

// ===================================================================
// --- CONFIGURACIÓN PARA LA LIBRERÍA NATIVA (JNI) ---
// ===================================================================

// 1. Registra (de forma perezosa) una tarea para copiar la librería .so
def copyNativeLib = tasks.register('copyNativeLib', Copy) {
    // Especifica de dónde viene el archivo.
    from project(':native-lib').tasks.named('linkDebug').map { it.linkedFile }

    // Especifica a dónde se copiará el archivo.
    into layout.buildDirectory.dir('libs/native')
}

// 2. Configura las tareas 'run' y 'assemble' para que dependan de la tarea de copia.
//    dependsOn puede aceptar un TaskProvider directamente.
tasks.named('run').configure {
    dependsOn copyNativeLib
}

tasks.named('assemble').configure {
    dependsOn copyNativeLib
}


application {
    mainClass = 'projectstalker.Main'

    // 3. Añade el path de la librería nativa a los argumentos de la JVM.
    //    Esto configura el -Djava.library.path automáticamente al ejecutar con 'gradle run'.
    applicationDefaultJvmArgs = [
            "-Djava.library.path=${layout.buildDirectory.dir('libs/native').get().asFile.absolutePath}",
            // Habilita la carga de la librería en el Singleton (para la tarea 'run')
            "-Dprojectstalker.native.enabled=true"
    ]
}

// ===================================================================
// --- DEPENDENCIAS ---
// ===================================================================

dependencies {
    // =======================================================
    // --- STACK DE BASE DE DATOS (POSTGRESQL) ---
    // =======================================================
    implementation 'org.postgresql:postgresql:42.7.3'
    implementation 'com.zaxxer:HikariCP:5.1.0'
    implementation 'org.jdbi:jdbi3-core:3.45.2'
    implementation 'org.jdbi:jdbi3-postgres:3.45.2'

    // =======================================================
    // --- STACK DE PRUEBAS ---
    // =======================================================
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
    testImplementation 'org.assertj:assertj-core:3.25.3'
    testImplementation 'org.mockito:mockito-core:5.12.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.12.0'

    // =======================================================
    // --- OTROS ---
    // =======================================================
    implementation 'io.github.cdimascio:dotenv-java:3.0.0'
    compileOnly 'org.projectlombok:lombok:1.18.32'
    annotationProcessor 'org.projectlombok:lombok:1.18.32'
    testCompileOnly 'org.projectlombok:lombok:1.18.32'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.32'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.1'
    implementation 'org.slf4j:slf4j-api:2.0.13'
    runtimeOnly 'ch.qos.logback:logback-classic:1.5.13'
    implementation 'org.knowm.xchart:xchart:3.8.6'

    // =======================================================
    // --- DEPENDENCIAS EXPLÍCITAS PARA JMH ---
    // =======================================================
    jmhImplementation 'org.openjdk.jmh:jmh-core:1.37'
    jmhAnnotationProcessor 'org.openjdk.jmh:jmh-generator-annprocess:1.37'
    jmhImplementation project

}
jmh {
    fork = 1
    warmupIterations = 2
    iterations = 3
    resultFormat = 'JSON'
}

// ===================================================================
// --- CONFIGURACIÓN DE TESTS ---
// ===================================================================

test {
    useJUnitPlatform {
        // Excluye los tests de GPU de la ejecución 'test' estándar y los benchmarks
        excludeTags 'GPU', 'Benchmark'
    }
}

// Tarea personalizada para ejecutar SÓLO los tests de integración de GPU
tasks.register('gpuTest', Test) {
    description = 'Ejecuta los tests de integración que requieren hardware de GPU.'
    group = 'verification'

    // Asegura que la librería nativa esté copiada antes de ejecutar
    dependsOn copyNativeLib

    // Indica a la tarea DÓNDE están las clases .class de los tests compilados
    testClassesDirs = sourceSets.test.output.classesDirs
    // Indica a la tarea QUÉ LIBRERÍAS (JARs) usar (JUnit, Mockito, etc.)
    classpath = sourceSets.test.runtimeClasspath

    // Apunta a la misma carpeta nativa que la tarea 'run'
    jvmArgs "-Djava.library.path=${layout.buildDirectory.dir('libs/native').get().asFile.absolutePath}"

    // Habilita la carga de la librería nativa en NativeManningGpaSingleton
    systemProperty 'projectstalker.native.enabled', 'true'

    useJUnitPlatform {
        // Incluye SÓLO los tests marcados con @Tag("GPU")
        includeTags 'GPU'
    }
    // Muestra una salida clara en la consola para esta tarea
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        showStandardStreams = true
        showExceptions true
        showCauses true
        showStackTraces true
        exceptionFormat "full"
    }
}
tasks.register('benchmark', Test) {
    description = 'Ejecuta las pruebas de rendimiento masivo CPU vs GPU.'
    group = 'verification'
    dependsOn copyNativeLib
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    jvmArgs "-Djava.library.path=${layout.buildDirectory.dir('libs/native').get().asFile.absolutePath}"
    systemProperty 'projectstalker.native.enabled', 'true'

    // para evitar pausas de Garbage Collection durante la medición.
    minHeapSize = "4G"
    maxHeapSize = "24G"
    jvmArgs "-XX:+UseG1GC"          // GC estándar y robusto
    jvmArgs "-XX:+AlwaysPreTouch"   // Reserva la RAM real al inicio (evita lag al asignar)
    jvmArgs "-XX:MaxGCPauseMillis=500" // Permite pausas largas (es un benchmark) para limpiar mejor
    // Forzar ejecución siempre
    outputs.upToDateWhen { false }

    useJUnitPlatform {
        includeTags 'Benchmark'
    }
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        showStandardStreams = true
        showExceptions true
        showCauses true
        showStackTraces true
        exceptionFormat "full"
    }
}